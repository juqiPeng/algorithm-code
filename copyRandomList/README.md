# 复杂链表的复制

## 要求

实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

## 样例

```shell
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

```shell
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```


```shell
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

```shell
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

## 思路


刚开始拿到这个题目的时候，心里想着，这不是很简单么？遍历链表。每个节点copy一遍，不就好了？
但是真正实现的时候才发现有坑存在！！

难点：在复制链表的过程中如何构建新链表各节点的 random 引用指向。

### 1. 方法一：哈希表

先用一个哈希表将链表节点的副本节点存储起来，后面复制的时候直接从哈希表中获取副本节点。这种方法虽然实现起来没有什么问题，但是仍然感到有一种暴力破解的感觉，无法完全发挥算法的优雅。

我们是不是存在第二种方法呢？假如我们直接通过遍历链表的方法动态创建副本？需要解决的主要是 random 的引用问题？问题在于我们这个原始链表的 random 有可能引用的是后面将会创建的节点，所以我们的 random 指向没有办法在一次遍历的过程中完成。

### 2. 方法二：迭代 + 节点拆分

此方法是一些大神提出来的一个非常巧妙的玩法。方法是我们可以将节点的副本插入原链表，那么副本节点的 random 指向就等于它原始节点指向的 random 节点的后继节点！！

不得不感叹！真是优雅啊！

node_copy.random = node_copy.pre.random.next